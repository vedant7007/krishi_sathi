const CropRule = require('../models/CropRule');
const { generateAdvisory, translateJSON } = require('../utils/gemini');

// GET /api/advisory?crop=cotton&soilType=black&season=kharif&lang=hi
exports.getAdvisory = async (req, res, next) => {
  try {
    const { crop, soilType, season, lang } = req.query;

    if (!crop) {
      return res.status(400).json({
        success: false,
        message: 'Crop parameter is required',
      });
    }

    const cropLower = crop.toLowerCase();
    const soilLower = soilType ? soilType.toLowerCase() : null;
    const seasonLower = season ? season.toLowerCase() : null;

    let advisory = null;
    let confidence = null;

    // Tier 1: Exact match (crop + soilType + season)
    if (soilLower && seasonLower) {
      advisory = await CropRule.findOne({
        crop: cropLower,
        soilType: soilLower,
        season: seasonLower,
      });
      if (advisory) confidence = 'exact';
    }

    // Tier 2: Partial match (crop + soilType OR crop + season)
    if (!advisory && soilLower) {
      advisory = await CropRule.findOne({
        crop: cropLower,
        soilType: soilLower,
      });
      if (advisory) confidence = 'partial';
    }

    if (!advisory && seasonLower) {
      advisory = await CropRule.findOne({
        crop: cropLower,
        season: seasonLower,
      });
      if (advisory) confidence = 'partial';
    }

    // Tier 3: General (crop only, soilType=any)
    if (!advisory) {
      advisory = await CropRule.findOne({
        crop: cropLower,
        $or: [
          { soilType: 'any' },
          { soilType: { $exists: false } },
        ],
      });
      if (advisory) confidence = 'general';
    }

    // Final DB fallback
    if (!advisory) {
      advisory = await CropRule.findOne({ crop: cropLower });
      if (advisory) confidence = 'general';
    }

    // Gemini AI fallback: generate advisory for crops not in DB
    if (!advisory) {
      try {
        // Generate directly in target language to avoid translation failures
        const targetLang = (lang && lang !== 'en') ? lang : null;
        const aiAdvisory = await generateAdvisory(cropLower, soilLower, seasonLower, targetLang);
        if (aiAdvisory) {
          let finalAdvisory = {
            crop: cropLower,
            soilType: soilLower || 'any',
            season: seasonLower || 'any',
            ...aiAdvisory,
            _aiGenerated: true,
          };
          console.log(`[Advisory] AI advisory generated${targetLang ? ` in ${targetLang}` : ''} for ${cropLower}`);

          return res.json({
            success: true,
            data: {
              advisory: finalAdvisory,
              confidence: 'ai_generated',
              query: { crop: cropLower, soilType: soilLower, season: seasonLower },
            },
            message: 'Advisory generated by AI',
          });
        }
      } catch (aiErr) {
        console.error('Gemini advisory error:', aiErr.message);
      }
    }

    if (!advisory) {
      return res.status(404).json({
        success: false,
        message: `No advisory found for crop: ${crop}`,
      });
    }

    const advisoryObj = advisory.toObject ? advisory.toObject() : { ...advisory };
    const safeAdvisory = {
      ...advisoryObj,
      fertilizer: advisoryObj.fertilizer || { type: 'N/A', quantity: 'N/A', schedule: 'N/A', notes: '' },
      irrigation: advisoryObj.irrigation || { method: 'N/A', frequency: 'N/A', waterPerAcre: 'N/A', notes: '' },
      pest: advisoryObj.pest || { commonPests: [], prevention: 'N/A', treatment: 'N/A', spraySchedule: 'N/A' },
      sowing: advisoryObj.sowing || { method: 'N/A', depth: 'N/A', spacing: 'N/A', bestTime: 'N/A', seedRate: 'N/A' },
      harvest: advisoryObj.harvest || { timing: 'N/A', signs: 'N/A', method: 'N/A', yield: 'N/A' },
      msp: advisoryObj.msp || { price: null, unit: 'â‚¹/quintal', year: 'N/A' },
    };

    // Translate content if lang != en
    let finalAdvisory = safeAdvisory;
    if (lang && lang !== 'en') {
      try {
        const { fertilizer, irrigation, pest, sowing, harvest } = safeAdvisory;
        console.log(`[Advisory] Translating to ${lang} for crop: ${cropLower}`);
        const translated = await translateJSON({ fertilizer, irrigation, pest, sowing, harvest }, lang);
        finalAdvisory = { ...safeAdvisory, ...translated };
        console.log(`[Advisory] Translation done for ${lang}`);
      } catch (err) {
        console.error(`[Advisory] Translation failed for ${lang}:`, err.message);
      }
    }

    res.json({
      success: true,
      data: {
        advisory: finalAdvisory,
        confidence,
        query: { crop: cropLower, soilType: soilLower, season: seasonLower },
      },
      message: `Advisory retrieved with ${confidence} match`,
    });
  } catch (error) {
    next(error);
  }
};

// GET /api/advisory/crops
exports.getCrops = async (req, res) => {
  try {
    const crops = await CropRule.distinct('crop');
    const cropList = crops.map((crop) => ({
      value: crop,
      name: crop.charAt(0).toUpperCase() + crop.slice(1),
    }));

    res.json({
      success: true,
      data: { crops: cropList },
      message: 'Supported crops retrieved',
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve crops',
    });
  }
};
